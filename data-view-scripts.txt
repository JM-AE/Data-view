class DataDashboard:
    def __init__(self, root):
        self.root = root
        self.root.title("Data Handling Dashboard")
        self.data = None
        self.plot_frame = None
        self.selected_column = tk.StringVar(self.root)
        self.selected_graph = tk.StringVar(self.root)
        self.graph_libraries = ["Matplotlib", "Seaborn", "Bokeh"]
        self.visualization_methods = ["Histogram", "Pie Chart", "Correlation Matrix"]

        # Create main frames
        self.create_main_layout()

    def create_main_layout(self):
        # Top buttons
        button_frame = tk.Frame(self.root)
        button_frame.pack(side=tk.TOP, fill=tk.X)

        tk.Button(button_frame, text="Load Data", command=self.load_data).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(button_frame, text="Describe Data", command=self.describe_data).pack(side=tk.LEFT, padx=5, pady=5)

        # Dropdowns and buttons
        self.column_dropdown = ttk.OptionMenu(button_frame, self.selected_column, "Select Column")
        self.column_dropdown.pack(side=tk.LEFT, padx=5, pady=5)

        self.graph_dropdown = ttk.OptionMenu(button_frame, self.selected_graph, "Select Graph", *self.visualization_methods)
        self.graph_dropdown.pack(side=tk.LEFT, padx=5, pady=5)

        tk.Button(button_frame, text="OK", command=self.confirm_selection).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Button(button_frame, text="Reset", command=self.reset_screen).pack(side=tk.LEFT, padx=5, pady=5)

        tk.Button(button_frame, text="Manipulate Data", command=self.manipulate_data).pack(side=tk.LEFT, padx=5, pady=5)

        # Data display area
        self.data_frame = ttk.Treeview(self.root)
        self.data_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(self.root, orient="vertical", command=self.data_frame.yview)
        scrollbar.pack(side=tk.LEFT, fill="y")
        self.data_frame.configure(yscrollcommand=scrollbar.set)

        # Plot area
        self.plot_frame = tk.Frame(self.root)
        self.plot_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)

        # Error display area
        self.error_message = tk.StringVar(self.root)
        self.error_label = tk.Label(self.root, textvariable=self.error_message, fg="red", anchor="w")
        self.error_label.pack(side=tk.BOTTOM, fill=tk.X)

    def reset_error_message(self):
        """Clears the error message."""
        self.error_message.set("")

    def clear_plot_area(self):
        """Clears the plot frame."""
        for widget in self.plot_frame.winfo_children():
            widget.destroy()

    def load_data(self):
        file_path = filedialog.askopenfilename(filetypes=[("CSV Files", "*.csv"), ("Excel Files", "*.xlsx")])
        if file_path:
            try:
                if file_path.endswith(".csv"):
                    self.data = pd.read_csv(file_path)
                elif file_path.endswith(".xlsx"):
                    self.data = pd.read_excel(file_path)
                self.reset_error_message()
                self.error_message.set("Data loaded successfully.")
                self.update_column_dropdown()
                self.display_dataframe()
            except Exception as e:
                self.error_message.set(f"Error loading data: {str(e)}")

    def describe_data(self):
        if self.data is not None:
            self.reset_error_message()
            desc = self.data.describe()
            self.display_dataframe(desc)
        else:
            self.error_message.set("Please load data first.")

    def update_column_dropdown(self):
        """Updates the column dropdown with current DataFrame columns."""
        if self.data is not None:
            menu = self.column_dropdown["menu"]
            menu.delete(0, "end")
            for column in self.data.columns:
                menu.add_command(label=column, command=lambda col=column: self.selected_column.set(col))

    def display_dataframe(self, df=None):
        """Displays the DataFrame in a Treeview widget."""
        if df is None:
            df = self.data
        self.data_frame.delete(*self.data_frame.get_children())
        self.data_frame["columns"] = list(df.columns)
        self.data_frame["show"] = "headings"

        for column in df.columns:
            self.data_frame.heading(column, text=column)

        for _, row in df.iterrows():
            self.data_frame.insert("", "end", values=list(row))

    def confirm_selection(self):
        """Executes the selected column and graph choice to display the plot."""
        if self.data is None:
            self.error_message.set("Please load data first.")
            return

        column = self.selected_column.get()
        if column not in self.data.columns:
            self.error_message.set("Please select a valid column.")
            return

        graph = self.selected_graph.get()
        if graph not in self.visualization_methods:
            self.error_message.set("Please select a valid graph type.")
            return

        self.reset_error_message()
        self.clear_plot_area()

        try:
            if graph == "Histogram":
                self.plot_histogram(column)
            elif graph == "Pie Chart":
                self.plot_pie_chart(column)
            elif graph == "Correlation Matrix":
                self.plot_correlation_matrix()
        except Exception as e:
            self.error_message.set(f"Error generating plot: {str(e)}")

    def plot_histogram(self, column):
        fig = Figure(figsize=(6, 4))
        ax = fig.add_subplot(111)
        ax.hist(self.data[column], bins=20, color="blue", edgecolor="black")
        ax.set_title(f"Histogram of {column}")
        ax.set_xlabel(column)
        ax.set_ylabel("Frequency")
        self.display_plot(fig)

    def plot_pie_chart(self, column):
        fig = Figure(figsize=(6, 4))
        ax = fig.add_subplot(111)
        self.data[column].value_counts().plot.pie(autopct="%1.1f%%", ax=ax)
        ax.set_title(f"Pie Chart of {column}")
        ax.set_ylabel("")  # Remove default ylabel
        self.display_plot(fig)

    def plot_correlation_matrix(self):
        fig = Figure(figsize=(6, 4))
        ax = fig.add_subplot(111)
        sns.heatmap(self.data.corr(), annot=True, cmap="coolwarm", ax=ax)
        ax.set_title("Correlation Matrix")
        self.display_plot(fig)

    def display_plot(self, fig):
        """Displays a Matplotlib figure in the Tkinter window."""
        canvas = FigureCanvasTkAgg(fig, master=self.plot_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)

    def reset_screen(self):
        """Resets the screen by clearing plots, error messages, and the DataFrame."""
        self.clear_plot_area()
        self.reset_error_message()
        self.data_frame.delete(*self.data_frame.get_children())
        self.error_message.set("Screen reset.")

    def manipulate_data(self):
        if self.data is None:
            self.error_message.set("Please load data first.")
            return

        option = tk.simpledialog.askstring("Data Manipulation", "Enter manipulation option (e.g., 'dropna', 'fillna'):")
        try:
            if option == "dropna":
                self.data.dropna(inplace=True)
                self.reset_error_message()
                self.error_message.set("Missing values dropped.")
            elif option == "fillna":
                fill_value = tk.simpledialog.askstring("Fill Value", "Enter value to fill missing data:")
                self.data.fillna(fill_value, inplace=True)
                self.reset_error_message()
                self.error_message.set("Missing values filled.")
            else:
                self.error_message.set("Invalid manipulation option.")
            self.update_column_dropdown()
            self.display_dataframe()
        except Exception as e:
            self.error_message.set(f"Error during manipulation: {str(e)}")


if __name__ == "__main__":
    root = tk.Tk()
    app = DataDashboard(root)
    root.mainloop()